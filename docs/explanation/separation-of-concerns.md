# 関心の分離について

> [!TLDR]
> Marko のアプローチは関心の分離に違反するものではなく、従来の技術ベースの分離よりも正しくこの原則を適用しています。

開発者が Marko の Tags API に初めて遭遇したとき、コンポーネントロジックを構造とスタイリングと密接に結合できることから、よくある懸念が生じます：「これは関心の分離に違反しているのではないか？」

この質問は、ソフトウェアエンジニアリングにおける最も基本的な原則の1つに触れていますが、「関心」が実際に何であるかについての根本的な誤解も明らかにしています。

## 実際の関心

シンプルなユーザーインターフェースコンポーネントを考えてみましょう：モーダルダイアログ。従来のファイルベースの分離では、次のように整理します：

```html
/* modal.html */
<button id="open-modal">Open Modal</button>
<div id="modal" class="modal">
  <button id="close-modal">×</button>
  <p>Modal content...</p>
</div>
```

```css
/* modal.css */
.modal {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border: 1px solid black;
}
```

```js
/* modal.js */
function openModal() {
  document.getElementById("modal").style.display = "block";
}

function closeModal() {
  document.getElementById("modal").style.display = "none";
}

document.getElementById("open-modal").addEventListener("click", openModal);
document.getElementById("close-modal").addEventListener("click", closeModal);
```

この整理は関心の分離に従っているように見えますが、**_実際の関心_**は何であるべきかを考えてみましょう：

1. **モーダルの動作**: 開く、閉じる、モーダルの状態を管理する
2. **視覚的なプレゼンテーション**: モーダルがどのように表示され、アニメーションするか
3. **ユーザーインタラクション**: ボタンクリック、キーボードナビゲーション
4. **アクセシビリティ**: フォーカス管理、スクリーンリーダーサポート

重要なことに気づきましょう：**すべての関心が HTML、CSS、JavaScript にまたがっています**。

- モーダルの開く動作には、JavaScript ロジック、CSS display プロパティ、HTML 構造の変更が必要です
- 「Escape キーで閉じる」などの機能を追加すると、HTML（フォーカス管理）、CSS（スタイリング）、JavaScript（イベント処理）に触れます

**根本的な問題**: 従来の分離は_技術_（HTML/CSS/JS ファイル）で分割しますが、意図は_機能的な関心_で分割することです。

## 根本的な問題

技術で分離する代わりに関心で分離する場合、いくつかの深刻な問題が生じます：

1. **断片化されたメンタルモデル**

   モーダルがどのように機能するかを理解する必要がある場合、3つの異なるファイルから情報を精神的につなぎ合わせる必要があります。認知的オーバーヘッドは、アプリケーションの複雑さとともに指数関数的に増加します。

1. **変更の増幅**

   「モーダルの外側をクリックしたときに自動的に閉じる」などのシンプルな機能を追加するには、HTML（イベント処理構造）、CSS（オーバーレイスタイリング）、JavaScript（イベントリスナー）の変更が必要です。単一の論理的変更が複数のファイルに分散します。

1. **壊れたカプセル化**

   コンポーネントの定義が複数のファイルに分散している場合、コンポーネントは真に自己完結できません。モーダルコンポーネントを移動または再利用するには、HTML、CSS、JavaScript ファイルの慎重な調整が必要です。

1. **メンテナンスオーバーヘッド**

   技術が分離されている場合、一貫性を確保することが困難になります。HTML が変更されると CSS クラスが孤立する可能性があり、JavaScript は存在しなくなった DOM 要素を参照する可能性があり、リファクタリングはファイル間の考古学的な探検になります。

## 機能性で整理する

Marko の Tags API は異なる哲学を受け入れています：**技術ではなく、機能と機能性でコードを整理する**。

同じモーダルコンポーネントが Marko でどのように見えるかを以下に示します：

```marko
/* modal.marko */
<let/open=false/>

<button onClick() { open = true }>
  Open Modal
</button>

<div.modal style={ display: open ? "block" : "none" }>
  <button onClick() { open = false }>×</button>
  <p>Modal content...</p>
</div>

<style>
  .modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 1px solid black;
  }
</style>
```

モーダルに関連するすべて（状態管理、DOM 構造、イベント処理、スタイリング）が単一のファイルに共同配置されていることに注目してください。これは関心の分離に違反するものではありません。**より良い関心の分離**です。

## 分離の境界

技術で分離する代わりに、Marko は実際のビジネス上の関心で分離することを推奨しています：

- **コンポーネントの境界**: 各 `.marko` ファイルは、まとまりのある機能の一部を表します
- **機能の境界**: 関連するコンポーネントはグループ化されます
- **ドメインの境界**: アプリケーションの異なる部分は論理的に分離されます
- **抽象化レベル**: 低レベルのユーティリティは、高レベルのコンポーネントから分離されます

このアプローチは、測定可能な改善をもたらします：

1. 認知的負荷の削減

   開発者が機能を理解または変更する必要がある場合、必要なものはすべて1か所にあります。複数のファイル間の関係を追跡する精神的なオーバーヘッドはありません。

1. より良いカプセル化

   各コンポーネントは真に自己完結しています。`.marko` ファイルを別のプロジェクトに移動でき、すべての依存関係を持ち込みます。

1. より簡単なリファクタリング

   コンポーネントを変更する必要がある場合、関連するすべてのコードが共同配置されています。遠くのファイルで関連する CSS ルールや JavaScript ハンドラを更新し忘れるリスクはありません。

1. 自然なスコープ

   スタイルと動作は、自然にコンポーネントにスコープされます。これにより、従来のアプローチに悩まされるグローバルスコープの汚染が排除されます。

Marko は境界がどこにあるべきかを規定するのではなく、アプリケーションのニーズに基づいて適切な分離を定義する力を与えます。たとえば、このフォームの電話番号入力のような機能が大きくなりすぎていると感じる場合：

```marko
<form>
  <label>
    Phone Number:
    <let/phoneNumber=""/>
    <input
      name="phone"
      type="tel"
      value=phoneNumber
      valueChange(value) {
        phoneNumber = value.replace(/\D/g, '').replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
      }
    />
  </label>
  <button type="submit">Submit</button>
</form>
```

別のコンポーネントに抽出できます：

```marko
/* index.marko */
<form>
  <label>
    Phone Number: <phone-input/>
  </label>
  <button type="submit">Submit</button>
</form>
```

```marko
/* phone-input.marko */
<let/number="">
<input
  name="phone"
  type="tel"
  value=number
  valueChange(value) {
    number = value.replace(/\D/g, '').replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
  }
/>
```

フレームワークは人為的な分離を強制しません。代わりに、特定のアプリケーションにとって意味のある**論理的な境界**で関心を分離するためのツールを提供します。

## 一般的な異議

この時点で、いくつかの懸念があるかもしれません。最も一般的なものに対処しましょう：

### 「これは単一責任の原則に違反する」

単一責任の原則は、クラスが変更する理由を1つだけ持つべきだと述べています。Marko コンポーネントは通常、_単一の責任_を持っており、それはユーザー向け機能の1つを実装することです。HTML、CSS、JavaScript を含むという事実は、クラスがデータとメソッドの両方を持つことが SRP に違反しないのと同様に、SRP に違反しません。

モーダルコンポーネントには1つの責任があります—モーダルであること。すべての HTML 構造、CSS スタイリング、JavaScript の動作は、その単一の目的に役立ちます。これらをファイル間で分割しても、より良い分離は作成されません。単一の関心の実装を断片化するだけです。

### 「再利用性はどうですか？」

関心の共同配置は、実際には再利用性を_改善_します。コンポーネントを再利用したい場合、必要なすべてのものを1つのパッケージで取得できます。関連する CSS ファイルや JavaScript の依存関係を探す必要はありません。

従来のアプローチ：

```sh
├── modal.html
├── modal.css
├── modal.js
└── modal-theme.css
```

Marko アプローチ：

```sh
└── modal.marko
```

### 「大きなコンポーネントは扱いにくい」

これは正当な懸念ですが、解決策は技術で分離することではありません。大きなコンポーネントをより小さく、より焦点を絞ったコンポーネントに分割することです。これはまさに Marko が推奨する種類の論理的分離です。

コンポーネントが大きくなりすぎている場合は、論理的なサブコンポーネントを抽出します：

```marko
<!-- 1つの巨大な user-profile.marko の代わりに、複数のコンポーネントに分割します -->
<user-avatar user=input.user/>
<user-details user=input.user/>
<user-actions user=input.user/>
<user-preferences user=input.user/>
```

これは、技術ではなく機能性に基づいてコンポーネントの境界を維持します。

### 「これはウェブ標準に逆らう」

ウェブ標準は技術（HTML、CSS、JavaScript）を定義しますが、ソースコードでそれらをどのように整理すべきかは規定していません。分離はツールの制限であり、標準の要件ではありませんでした。

次のことを考えてください：

- **Web Components** は、HTML、CSS、JavaScript を単一のカスタム要素に共同配置します
- **CSS-in-JS** は、スタイリングを JavaScript に持ち込みます
- **スタイル属性**は、常に HTML と CSS を混在させてきました

ウェブプラットフォーム自体が、より統合されたアプローチに向かって進んでいます。

## 業界のトレンド

Marko はこのアプローチで孤立していません。フロントエンド業界は何年もこの方向に進んでいます：

- **Vue.js**: 単一ファイルコンポーネント（SFC）は、テンプレート、スクリプト、スタイルを共同配置します
- **React**: JSX は HTML と JavaScript を混在させます。CSS-in-JS ソリューションは、スタイリングをコンポーネントに近づけます
- **Svelte**: コンポーネントは、マークアップ、スタイリング、ロジックを単一のファイルに含めます
- **Angular**: コンポーネントデコレーターは、テンプレートとスタイルをクラスと共同配置します

他の技術スタックでも、同様のパターンが見られます：

- **iOS**: SwiftUI はレイアウトと動作を組み合わせます
- **Android**: Jetpack Compose は UI とロジックを統合します
- **デスクトップ**: 多くの最新 UI フレームワークは、コンポーネントベースのアプローチを支持します

## 結論

Marko のアプローチは、関心の分離を放棄することではなく、その原則をより慎重に適用することです。任意の技術的な境界で分離する代わりに、開発者が実際にユーザーインターフェースを考え、構築する方法と一致する論理的で機能的な境界で分離します。

その結果、理解、変更、維持が容易なコードになります。コンポーネントは、複数のファイルに散在する断片化された部分ではなく、真の機能の単位になります。このアプローチは、**関連するものは近くにあるべき**という原則を尊重しながら、実際に重要な場所で明確な分離を維持します。

問題は、関心を分離するかどうかではなく、**どの関心を分離するか**、**どこに境界を引くか**です。Marko の Tags API は、ウェブ技術の分離に関する時代遅れの仮定ではなく、アプリケーションの実際のニーズに基づいてこれらの決定を行う柔軟性を提供します。

## さらに読む

- [ネストされたリアクティビティ](./nested-reactivity.md)
- [パフォーマンスの最適化](./optimizing-performance.md)
