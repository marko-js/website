# 状態における不変データ

> [!TLDR]
> - 不変更新は隠れた副作用を防ぐ
> - 状態の関数としての UI には不変性が必要
> - サーバーからクライアントへの引き渡しにはシリアライズ可能な状態が必要

Marko は、アプリケーションの状態を不変のプレーンデータとして扱うことを推奨しています。これにより、レンダリングモデルが関数型プログラミングと整合します：UI は入力と状態の決定論的な関数です。また、コンパイラとランタイムが更新を最適化し、サーバーとクライアント間で安全に作業を引き渡すことができます。

## 不変性

不変更新は、データをその場で変更するのではなく、置き換えます。これにより、隠れた結合を避け、変更を理解しやすくし、更新が確実に検出されるようにします。

この Marko テンプレートを考えてみましょう。配列を再割り当てすると更新がトリガーされますが、その場で変更してもトリガーされません。

```marko
/* list.marko */
<let/items=["alpha", "beta"]>

<ul>
  <for|item| of=items>
    <li>${item}</li>
  </for>
  <button onClick() {
    // ❌ 悪い例: その場での変更
    items.push("gamma")

    // ✅ 良い例: 不変更新
    items = items.concat("gamma");
  }>Add</button>
</ul>
```

不変更新は、Marko の代入ベースのリアクティビティと自然に連携します。値（オブジェクト、配列、マップのような構造）を置き換えることで、変更の伝播が明示的で信頼性の高いものになります。

## 関数型 UI

現代の UI フレームワークでは、開発者は**レンダリングされた出力**を**状態の関数**として見るように推奨されています。これは、状態の変更が可視化され、暗黙的な副作用を持たない場合に機能します。その場での変更はそのメンタルモデルを壊し、ビューをいつどこで更新すべきかを隠してしまう可能性があります。

```marko
/* profile.marko */
<let/user={ name: "Ada", clicks: 0 }>

<p>Hello, ${user.name}! (${user.clicks} clicks)</p>

<button onClick() {
  // ❌ 悪い例: その場での変更
  user.clicks++;

  // ✅ 良い例: 不変更新
  user = { ...user, clicks: user.clicks + 1 };
}>Visit</button>
```

`user` を置き換えることで、ビューは新しい状態の関数として決定論的に更新されます。

## シリアライゼーション

サーバーからクライアントに作業を引き渡すには、状態をシリアライズする必要があります。シリアライズ可能なデータのみが、HTML に確実に埋め込まれ、後でハイドレートできます。クラスインスタンス、DOM ノード、一部のタイプのクロージャはシリアライズできないため、状態に保存すべきではありません。

```marko
/* cart.marko */
// ✅ 良い例: シリアライズ可能なデータ
<let/cart={ items: [{ id: 1, qty: 2 }] }>

// ❌ 悪い例: 状態内でシリアライズ不可能（クラス/関数/DOM）
<let/cart=new Cart([{ id: 1, qty: 2 }])>
```

状態をシリアライズ可能に保つことで、サーバー上での HTML のストリーミングと、脆弱なカスタムハイドレーションロジックなしでブラウザでのインタラクティブな引き渡しが可能になります。

> [!TIP]
> サポートされているデータと避けるべきパターンの詳細については、[シリアライズ可能な状態](./serializable-state.md)を参照してください

## さらに読む

- [リアクティビティ](../reference/reactivity.md)
- [ネストされたリアクティビティ](./nested-reactivity.md)
- [細粒度バンドリング](./fine-grained-bundling.md)
