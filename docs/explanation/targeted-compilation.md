# ターゲット コンパイル

> [!TLDR]
> - Marko は環境に基づいて何をコンパイルするかを選択する
> - サーバー上での文字列連結
> - クライアント上での DOM 操作

Marko のコンパイラは、ターゲット環境に基づいて異なるコードをインテリジェントに生成し、特定のランタイム制約に合わせてテンプレートを最適化します。このデュアルターゲットアプローチにより、開発者体験を損なったり、アーキテクチャの決定を強制したりすることなく、サーバーとクライアントの両方で最大のパフォーマンスを保証します。

万能のコンパイル戦略を使用する代わりに、Marko はサーバーサイドレンダリングとクライアントサイドのインタラクションが根本的に異なるパフォーマンス特性と最適化の機会を持っていることを認識しています。

## サーバーコンパイル

サーバー上では、テンプレートは効率的な文字列操作を通じて HTML を構築する文字列連結操作にコンパイルされ、DOM 作成のオーバーヘッドを完全に回避します。

この Marko テンプレートを考えてみましょう：

```marko
/* article.marko */
<article>
  <h2>${input.title}</h2>
  <if=input.featured>
    <span class="badge">Featured</span>
  </if>
</article>
```

コンパイラは静的マークアップを事前計算し、動的値をエスケープして挿入し、条件ロジックを適切な HTML セグメントを書き込む最小限の分岐に変換します。高度な最適化には、静的部分の事前評価と、サーバーコードが Marko の [HTML ストリーミング](./streaming.md) 機能とシームレスに連携することの保証が含まれます。

## クライアントコンパイル

テンプレートがインタラクティビティを必要とする場合、クライアントコンパイルは異なるアプローチを取ります。完全な HTML レンダリングコードを生成する代わりに、ターゲット DOM 更新のための最小限の JavaScript を生成します。

前の例のインタラクティブバージョンを考えてみましょう：

```marko
/* article.marko */
<article>
  <h2>${input.title}</h2>

  // インタラクティブなライクトグル
  <let/liked:=input.liked>
  <button class=liked && 'liked' onClick() { liked = !liked }>
    ${liked ? '❤️ liked' : '🤍 like'}
  </button>
</article>
```

コンパイラは、インタラクティブな部分に専念する最小限の JavaScript を生成します：宣言された変数のリアクティブ状態、影響を受ける DOM ノードのみを変更するターゲット更新関数、必要な更新をトリガーするイベントハンドラ。

`${input.title}` のような静的コンテンツは、初期レンダリング後に変更されないため、クライアント側の JavaScript を生成しません。

## 環境の調整

サーバーとクライアントのコンパイルはシームレスに連携します。サーバーは完全な初期 HTML をレンダリングし、クライアントはインタラクティビティに必要な最小限の JavaScript のみを受け取ります。このパターンは[細粒度バンドリング](./fine-grained-bundling.md)と整合します。

静的コンテンツとインタラクティブコンテンツを混在させたタブコンポーネントを考えてみましょう：

```marko
/* tabs.marko */
// 静的
<h1>${input.title}</h1>

// インタラクティブ
<let/active=0>
<div>
  <for|section, i| of=input.section>
    <button
      aria-selected=(i === active && 'true')
      onClick() { active = i }
    >
      ${section.title}
    </button>
  </for>
</div>

// インタラクティブ状態に依存する静的コンテンツ
<for|section, i| of=input.section>
  <div hidden=(i !== active)>${section.content}</div>
</for>
```

サーバーコンパイルは、ヘッダーと初期タブ状態を含む初期 HTML をレンダリングします。クライアントコンパイルは、タブの切り替えと可視性の更新のためだけに JavaScript を生成します。バンドルには、静的ヘッダーや静的タブコンテンツをレンダリングするためのコードは含まれません。

## メリット

ターゲットコンパイルは、アプリケーションがスケールするにつれて改善される複合的なパフォーマンスメリットを提供します。

コンポーネントは自然な構文を使用して一度だけ記述され、コンパイラが環境固有の最適化を自動的に処理します。別々のサーバーとクライアントの実装を維持したり、異なるレンダリングアプローチ間で調整したりする必要はありません。

サーバーサイドレンダリングは文字列操作を通じて最大のスループットを達成し、クライアントサイドの更新はターゲット DOM 操作を通じて最小限のオーバーヘッドを達成します。各環境は、その特定の制約に最適化されたコードを取得します。

アプリケーションのインタラクティブな部分のみがクライアント側の JavaScript を生成するため、コードベースのサイズではなく実際のインタラクティビティに応じてスケールする自然に最適なバンドルサイズが作成されます。アプリケーションは JavaScript なしで完全に機能し、段階的に拡張されるため、すべてのユーザーに完全な機能を維持しながら、多様なユーザー環境をサポートします。

このコンパイル戦略は、ランタイムからビルド時に複雑さをシフトするという Marko の哲学を体現しており、開発者が機能に集中できるようにしながら、コンパイラが実行環境全体でパフォーマンスの最適化を自動的に処理します。
