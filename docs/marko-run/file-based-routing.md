# ファイルベースルーティング

## ルートディレクトリ

プラグインは、設定された **ルートディレクトリ** でルートファイルを検索します。デフォルトでは、Vite 設定ファイルからの相対パスで `./src/routes` に設定されています。このディレクトリには、アプリケーションのすべてのルーティングロジックが含まれます。

異なるルートディレクトリを設定する方法は次のとおりです：

```ts
/* vite.config.ts */
import { defineConfig } from "vite";
import marko from "@marko/run/vite";

export default defineConfig({
  plugins: [
    marko({
      routesDir: "src/pages", // ルートディレクトリとして `./src/pages`（このファイルからの相対パス）を使用
    }),
  ],
});
```

## ルーティング可能なファイル

ルーターは特定のファイル名のみを認識し、すべて `+` で始まります。以下のファイル名は、アプリケーションの [ルートディレクトリ](#ルートディレクトリ) 内の任意のディレクトリで検出されます。

### `+page.marko`

これらのファイルは、現在のディレクトリパスにルートを確立し、`GET` リクエストに対してページの HTML コンテンツが提供されます。提供されるパスごとに存在できるページは 1 つだけです。

### `+layout.marko`

これらのファイルは **レイアウトコンポーネント** を提供し、すべてのネストされたレイアウトとページをラップします。情報は [`$global`](../reference/language.md#global) と `input` から取得されます。
レイアウトは他の Marko コンポーネントと同様で、追加の制約はありません。各レイアウトは、リクエスト、パスパラメータ、URL、ルートメタデータを入力として受け取り、レンダリングされるネストされたページを参照する `content` も受け取ります。

```marko
/* +layout.marko */
export interface Input {
  content: Marko.Body;
}

<main>
  <h1>My Products</h1>

  <${input.content}/> // ここでページまたはレイアウトをレンダリング
</main>
```

### `+handler.*`

これらのファイルは、`GET`、`POST`、`PUT`、`DELETE` HTTP メソッドのリクエストを処理できる現在のディレクトリパスにルートを確立します。<!-- TODO: what about HEAD? -->

通常、これらはプロジェクトに応じて `.js` または `.ts` ファイルになります。ページと同様に、提供されるパスごとに各メソッドのハンドラーは 1 つだけ存在できます。ハンドラーは関数をエクスポートする必要があります

- 有効なエクスポートは、`GET`、`POST`、`PUT`、または `DELETE` という名前の関数です
- エクスポートは以下のいずれかになります
  - ハンドラー関数（下記参照）
  - ハンドラー関数の配列 - 順番に呼び出されて構成されます
  - ハンドラー関数またはハンドラー関数の配列に解決される Promise
- ハンドラー関数は同期または非同期関数で

  - `context` と `next` 引数を受け取ります
    - `context` 引数には、WHATWG リクエストオブジェクト、パスパラメータ、URL、ルートメタデータが含まれます
    - `next` 引数は、該当する場合は `GET` リクエストのページを呼び出すか、`204` レスポンスを返します
  - WHATWG レスポンスを返すか、WHATWG レスポンスをスローするか、undefined を返します。関数が undefined を返す場合、`next` 引数が自動的に呼び出され、レスポンスとして使用されます

    ```ts
    /* +handler.ts */
    export function POST(context, next) {
      const { request, params, url, meta } = context;
      return new Response("Successfully updated", { status: 200 });
    }

    export async function GET(context, next) {
      // `next` を呼び出す前に何かをする
      const response = await next();
      return response;
    }
    ```

### `+middleware.*`

これらのファイルはレイアウトに似ていますが、ハンドラー用です。ミドルウェアファイルはハンドラーの前に呼び出され、前後に任意の作業を実行できます。

> [!NOTE]
> ハンドラーとは異なり、ミドルウェアはすべての HTTP メソッドで実行されます。

- `default` エクスポートが必要で、以下のいずれかになります
  - ハンドラー関数（下記参照）
  - ハンドラー関数の配列 - 順番に呼び出されて構成されます
  - ハンドラー関数またはハンドラー関数の配列に解決される Promise
- ハンドラー関数は同期または非同期関数で

  - `context` と `next` 引数を受け取ります
    - `context` 引数には、WHATWG リクエストオブジェクト、パスパラメータ、URL、ルートメタデータが含まれます
    - `next` 引数は、該当する場合は `GET` リクエストのページを呼び出すか、`204` レスポンスを返します
  - WHATWG レスポンスを返すか、WHATWG レスポンスをスローするか、undefined を返します。関数が undefined を返す場合、`next` 引数が自動的に呼び出され、レスポンスとして使用されます

    ```ts
    /* +middleware.ts */
    export default async function (context, next) {
      const requestName = `${context.request.method} ${context.url.href}`;
      let success = true;
      console.log(`${requestName} request started`);
      try {
        return await next(); // 後続のミドルウェア、ハンドラー、ページを待機
      } catch (err) {
        success = false;
        throw err;
      } finally {
        console.log(
          `${requestName} completed ${success ? "successfully" : "with errors"}`,
        );
      }
    }
    ```

### `+meta.*`

これらのファイルは、ルートに添付する静的メタデータを表します。このメタデータは、ルートを呼び出すときにルート `context` で自動的に提供されます。

## 特別なファイル

[ルートディレクトリ](#ルートディレクトリ) 下の任意のディレクトリで定義できる上記のファイルに加えて、一部の特別なファイルはそのトップレベルでのみ定義できます。<!-- TODO: do we want to keep this restriction? Having nested 404s would be handy for disambiguating things like "there's no user with that name" or "that promotion wasn't found, it may have expired" -->

これらの特別なページは、ルートレイアウトファイル（デフォルト設定では `pages/+layout.marko`）の対象となります。

### `+404.marko`

この特別なページは、以下の条件のリクエストに応答します：

- `Accept` リクエストヘッダーに `text/html` が含まれている
- _かつ_ 他のハンドラーまたはページがリクエストをレンダリングしなかった

このページでのレスポンスは `404` ステータスコードになります。

### `+500.marko`

この特別なページは、以下の条件のリクエストに応答します：

- `Accept` リクエストヘッダーに `text/html` が含まれている
- _かつ_ リクエストの処理中にキャッチされないエラーが発生した

このページでのレスポンスは `500` ステータスコードになります。

## 実行順序

次のようなルートディレクトリ構造が与えられた場合

```
routes/
  about/
    +handler.js
    +layout.marko
    +middleware.js
    +page.marko
  +layout.marko
  +middleware.js
  +page.marko
```

パス `/about` がリクエストされると、ルーティング可能なファイルは次の順序で実行されます：

1. ルートから最も近いものから葉に最も近いものまでのミドルウェア
2. ハンドラー
3. ルートから最も近いものから葉に最も近いものまでのレイアウト
4. ページ

<!-- mermaid diagram from README -->

## パス構造

[ルートディレクトリ](#ルートディレクトリ) 内では、ディレクトリ構造によってルートが提供されるパスが決まります。ディレクトリ名には、**静的**、**パスレス**、**動的**、**キャッチオール** の 4 つのタイプがあります。

1. **静的ディレクトリ** - 最も一般的なタイプであり、デフォルトの動作です。各静的ディレクトリは、従来のファイルサーバーと同様に、ルートの提供パスにセグメントとしてその名前を提供します。ディレクトリ名が以下のタイプのいずれかの要件に一致しない限り、静的ディレクトリと見なされます。

   例：

   ```
   /foo
   /users
   /projects
   ```

2. **パスレスディレクトリ** - これらのディレクトリは、ルートの提供パスにその名前を提供 **しません**。アンダースコア（`_`）で始まるディレクトリ名は、ルートを解析する際に無視されます。

   例：

   ```
   /_users
   /_public
   ```

3. **動的ディレクトリ** - これらのディレクトリは、ルートの提供パスに動的パラメータを導入し、そのセグメントの任意の値と一致します。1 つのドル記号（`$`）で始まるディレクトリ名は動的ディレクトリになり、残りのディレクトリ名が実行時のパラメータになります。ディレクトリ名が正確に `$` の場合、パラメータはキャプチャされませんが、一致します。

   例：

   ```
   /$id
     /$name
   /$
   ```

4. **キャッチオールディレクトリ** - これらのディレクトリは動的ディレクトリに似ており、動的パラメータを導入しますが、単一のパスセグメントと一致するのではなく、パスの最後まで一致します。2 つのドル記号（`$$`）で始まるディレクトリはキャッチオールディレクトリになり、残りのディレクトリ名が実行時のパラメータになります。`$$` という名前のディレクトリの場合、パラメータ名はキャプチャされませんが、一致します。キャッチオールディレクトリは、ルートを含む任意のレベルで `404` Not Found ルートを作成するために使用できます。

   キャッチオールディレクトリは任意のパスセグメントと一致し、パスの残りを消費するため、その中にルートファイルをネストすることはできず、それ以上のディレクトリは走査されません。

   例：

   ```
   /$$all
     /$$rest
   /$$
   ```

## フラットルート

フラットルートを使用すると、追加のディレクトリを必要とせずにパスを定義できます。代わりに、ディレクトリ構造をファイル名またはディレクトリ名で定義できます。これにより、ルートをディレクトリ構造から切り離したり、必要に応じて配置したりできます。フラットルートを定義するには、ピリオド（`.`）を使用して各パスセグメントを区切ります。これは新しいディレクトリを作成するのと全く同じように動作し、各セグメントは上記で説明した静的、動的、パスレスルートのルールを使用して解析されます。

フラットルート構文は、ディレクトリとルーティング可能なファイル（ページ、ハンドラー、ミドルウェアなど）の両方に使用できます。これらのファイルの場合、プラス（`+`）の前にあるものはすべてフラットルートとして扱われます。

たとえば、ルートレイアウトとプロジェクトレイアウトを使用して `/projects/$projectId/members` にページを定義するには：

フラットルートを使用しない場合、次のようなファイル構造になります：

```
routes/
  projects/
    $projectId/
    $members/
      +page.marko
        +layout.marko
        +layout.marko
```

フラットルートを使用すると、ディレクトリで定義されたパスをファイルに移動し、ピリオドで区切ります

```
routes/
  +layout.marko
  projects+layout.marko
  projects.$projectId.members+page.marko
```

さらに、フォルダー名でフラットルート構文を使用して、重複を減らすためにディレクトリの下にファイルを整理し続けることができます

```
routes/
  projects.$projectId/
  +layout.marko
  members+page.marko
  +layout.marko
```

最後に、フラットルートとディレクトリで定義されたルートはすべて同等に扱われ、マージされます。たとえば、このページにはレイアウトが適用されます

```
routes/
  projects/
    $projectId/
      +layout.marko
  projects.$projectId+page.marko
```

## 複数のパス、グループ、オプショナルセグメント

複数のセグメントを記述するだけでなく、フラットルート構文は、複数のパスと一致するルートとオプショナルなセグメントの定義をサポートしています。複数のパスと一致するルートを記述するには、カンマ（`,`）を使用して各ルートを定義します。

たとえば、次のページは `/projects/$projectId/members` と `/projects/$projectId/people` に一致します

```
routes/
  projects.$projectId.members,projects.$projectId.people+page.marko
```

このファイル名は少し長いので、次のようにすることもできます

```
routes/
  projects.$projectId
  members,people+page.marko
```

別の概念を導入することで、これを簡素化できます：**グループ化**。グループを使用すると、括弧（`(` と `)`）で囲むことで、複数のサブパスと一致するフラットルート内のセグメントを定義できます。この例では、次のようにできます：

```
routes/
  projects.$projectId.(members,people)+page.marko
```

これはグループ化の簡単な例ですが、グループをネストして、必要なだけ複雑にすることができます。

最後の概念は **オプショナリティ** です。空のセグメントまたはパスレスセグメントを別の値と一緒に導入することで、そのセグメントをオプショナルにすることができます。たとえば、`/projects` と `/projects/home` に一致するページが必要な場合、`home` をオプショナルに一致させるフラットルートを作成できます

```
routes/
  projects.(home,)+page.marko
```

または

```
routes/
  projects.(home,_pathless)+page.marko
```

これらはどちらもパスに一致するルートを作成しますが、セマンティクスが少し異なります。パスレスセグメントを使用することは、パスレスディレクトリを作成することと同じで、ミドルウェアとレイアウトを分離できます。空のセグメントを使用することは、現在の場所にファイルを定義することと同じです。
