import type { PlaygroundFile } from "../../../playground.marko";
client import WritableDOMStream from "writable-dom";
client import { compile } from "../utils/compiler";
export interface Input {
  value: PlaygroundFile[];
  selected: number;
  render?: boolean;
  output?: "dom" | "html" | "hydrate";
}

client let worker: Worker | undefined;

let/error=null as unknown
let-debounce/files=input.value

if=error
  pre.error -- ${error}

iframe/$frame title="code output"

style --
  pre.error {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
  }

  pre.error + iframe {
    visibility: hidden;
  }

script --
  const signal = $signal;
  const signalOpt = { signal };
  try {
    const compiled = await compile(files);

    if (signal.aborted) return;

    const [stream, body] = await Promise.all([
      new Promise<ReadableStream<Uint8Array<ArrayBufferLike>>>((resolve, reject) => {
        worker?.terminate();
        worker = new Worker(compiled.server.js!, { type: "module" });
        worker.addEventListener("error", reject, signalOpt);
        worker.addEventListener("message", ({ data }) => {
          if (data && data instanceof ReadableStream) {
            resolve(data);
          }
        }, signalOpt);
      }),
      new Promise<HTMLBodyElement>((resolve, reject) => {
        const frame = $frame();
        frame.addEventListener("error", reject, signalOpt);
        frame.addEventListener("load", () => {
          const win = frame.contentWindow!;
          win.addEventListener("error", handleError, signalOpt);
          win.addEventListener("unhandledrejection", handleError, signalOpt);
          resolve(frame.contentDocument!.body as HTMLBodyElement);
          function handleError(ev: ErrorEvent | PromiseRejectionEvent) {
            if (!ev.defaultPrevented) {
              let err = "error" in ev ? ev.error : ev.reason || ev;
              if ("detail" in err) err = err.detail;
              error = err;
              console.error(err);
              ev.preventDefault();
            }
            return true;
          }
        }, signalOpt);
        frame.srcdoc = (
          (compiled.client.css ? `<link rel=stylesheet href="${compiled.client.css}">` : "") +
          (compiled.client.js ? `<script type="module" async src="${compiled.client.js}"></script>` : "") +
          "<body></body>"
        );
      })
    ]);

    if (signal.aborted) return;

    await stream
      .pipeThrough(new TextDecoderStream(), signalOpt)
      .pipeTo(new WritableDOMStream(body), signalOpt);
    error = null;
  } catch (err) {
    if (!signal.aborted) {
      error = err;
      console.error(err);
    }
  }
